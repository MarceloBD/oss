import { DMMF, DMMFClass, Engine } from './runtime';
/**
 * Utility Types
 */
export declare type Enumerable<T> = T | Array<T>;
export declare type MergeTruthyValues<R extends object, S extends object> = {
    [key in keyof S | keyof R]: key extends false ? never : key extends keyof S ? S[key] extends false ? never : S[key] : key extends keyof R ? R[key] : never;
};
export declare type CleanupNever<T> = {
    [key in keyof T]: T[key] extends never ? never : key;
}[keyof T];
/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PhotonFetcher {
    private readonly photon;
    private readonly engine;
    private readonly debug;
    private readonly hooks?;
    constructor(photon: Photon, engine: Engine, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, path?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    protected unpack(data: any, path: string[], rootField?: string, isList?: boolean): any;
}
/**
 * Client
**/
export declare type Datasources = {
    db?: string;
};
export interface PhotonOptions {
    datasources?: Datasources;
    debug?: boolean | {
        engine?: boolean;
        library?: boolean;
    };
    /**
     * You probably don't want to use this. `__internal` is used by internal tooling.
     */
    __internal?: {
        hooks?: Hooks;
        engine?: {
            cwd?: string;
            binaryPath?: string;
        };
    };
}
export declare type Hooks = {
    beforeRequest?: (options: {
        query: string;
        path: string[];
        rootField?: string;
        typeName?: string;
        document: any;
    }) => any;
};
export default class Photon {
    private fetcher;
    private readonly dmmf;
    private readonly engine;
    private readonly datamodel;
    private connectionPromise?;
    constructor(options?: PhotonOptions);
    private connectEngine;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    readonly knexMigrations: KnexMigrationDelegate;
    readonly users: UserDelegate;
}
export declare const OrderByArg: {
    asc: "asc";
    desc: "desc";
};
export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg];
/**
 * Model KnexMigration
 */
export declare type KnexMigration = {
    id: number;
    batch: number | null;
    migrationTime: string | null;
    name: string | null;
};
export declare type KnexMigrationScalars = 'id' | 'batch' | 'migrationTime' | 'name';
export declare type KnexMigrationSelect = {
    id?: boolean;
    batch?: boolean;
    migrationTime?: boolean;
    name?: boolean;
};
export declare type KnexMigrationInclude = {};
declare type KnexMigrationDefault = {
    id: true;
    batch: true;
    migrationTime: true;
    name: true;
};
declare type KnexMigrationGetSelectPayload<S extends boolean | KnexMigrationSelect> = S extends true ? KnexMigration : S extends KnexMigrationSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends KnexMigrationScalars ? KnexMigration[P] : never;
} : never;
declare type KnexMigrationGetIncludePayload<S extends boolean | KnexMigrationInclude> = S extends true ? KnexMigration : S extends KnexMigrationInclude ? {
    [P in CleanupNever<MergeTruthyValues<KnexMigrationDefault, S>>]: P extends KnexMigrationScalars ? KnexMigration[P] : never;
} : never;
export interface KnexMigrationDelegate {
    <T extends FindManyKnexMigrationArgs>(args?: Subset<T, FindManyKnexMigrationArgs>): T extends FindManyKnexMigrationArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyKnexMigrationSelectArgs ? Promise<Array<KnexMigrationGetSelectPayload<ExtractFindManyKnexMigrationSelectArgs<T>>>> : T extends FindManyKnexMigrationIncludeArgs ? Promise<Array<KnexMigrationGetIncludePayload<ExtractFindManyKnexMigrationIncludeArgs<T>>>> : Promise<Array<KnexMigration>>;
    findOne<T extends FindOneKnexMigrationArgs>(args: Subset<T, FindOneKnexMigrationArgs>): T extends FindOneKnexMigrationArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneKnexMigrationSelectArgs ? Promise<KnexMigrationGetSelectPayload<ExtractFindOneKnexMigrationSelectArgs<T>>> : T extends FindOneKnexMigrationIncludeArgs ? Promise<KnexMigrationGetIncludePayload<ExtractFindOneKnexMigrationIncludeArgs<T>>> : KnexMigrationClient<KnexMigration>;
    findMany<T extends FindManyKnexMigrationArgs>(args?: Subset<T, FindManyKnexMigrationArgs>): T extends FindManyKnexMigrationArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyKnexMigrationSelectArgs ? Promise<Array<KnexMigrationGetSelectPayload<ExtractFindManyKnexMigrationSelectArgs<T>>>> : T extends FindManyKnexMigrationIncludeArgs ? Promise<Array<KnexMigrationGetIncludePayload<ExtractFindManyKnexMigrationIncludeArgs<T>>>> : Promise<Array<KnexMigration>>;
    create<T extends KnexMigrationCreateArgs>(args: Subset<T, KnexMigrationCreateArgs>): T extends KnexMigrationCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends KnexMigrationSelectCreateArgs ? Promise<KnexMigrationGetSelectPayload<ExtractKnexMigrationSelectCreateArgs<T>>> : T extends KnexMigrationIncludeCreateArgs ? Promise<KnexMigrationGetIncludePayload<ExtractKnexMigrationIncludeCreateArgs<T>>> : KnexMigrationClient<KnexMigration>;
    delete<T extends KnexMigrationDeleteArgs>(args: Subset<T, KnexMigrationDeleteArgs>): T extends KnexMigrationDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends KnexMigrationSelectDeleteArgs ? Promise<KnexMigrationGetSelectPayload<ExtractKnexMigrationSelectDeleteArgs<T>>> : T extends KnexMigrationIncludeDeleteArgs ? Promise<KnexMigrationGetIncludePayload<ExtractKnexMigrationIncludeDeleteArgs<T>>> : KnexMigrationClient<KnexMigration>;
    update<T extends KnexMigrationUpdateArgs>(args: Subset<T, KnexMigrationUpdateArgs>): T extends KnexMigrationUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends KnexMigrationSelectUpdateArgs ? Promise<KnexMigrationGetSelectPayload<ExtractKnexMigrationSelectUpdateArgs<T>>> : T extends KnexMigrationIncludeUpdateArgs ? Promise<KnexMigrationGetIncludePayload<ExtractKnexMigrationIncludeUpdateArgs<T>>> : KnexMigrationClient<KnexMigration>;
    deleteMany<T extends KnexMigrationDeleteManyArgs>(args: Subset<T, KnexMigrationDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends KnexMigrationUpdateManyArgs>(args: Subset<T, KnexMigrationUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends KnexMigrationUpsertArgs>(args: Subset<T, KnexMigrationUpsertArgs>): T extends KnexMigrationUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends KnexMigrationSelectUpsertArgs ? Promise<KnexMigrationGetSelectPayload<ExtractKnexMigrationSelectUpsertArgs<T>>> : T extends KnexMigrationIncludeUpsertArgs ? Promise<KnexMigrationGetIncludePayload<ExtractKnexMigrationIncludeUpsertArgs<T>>> : KnexMigrationClient<KnexMigration>;
}
export declare class KnexMigrationClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    private readonly _document;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * KnexMigration findOne
 */
export declare type FindOneKnexMigrationArgs = {
    select?: KnexMigrationSelect | null;
    include?: KnexMigrationInclude | null;
    where: KnexMigrationWhereUniqueInput;
};
export declare type FindOneKnexMigrationArgsRequired = {
    select: KnexMigrationSelect;
    include: KnexMigrationInclude;
    where: KnexMigrationWhereUniqueInput;
};
export declare type FindOneKnexMigrationSelectArgs = {
    select: KnexMigrationSelect;
    where: KnexMigrationWhereUniqueInput;
};
export declare type FindOneKnexMigrationSelectArgsOptional = {
    select?: KnexMigrationSelect | null;
    where: KnexMigrationWhereUniqueInput;
};
export declare type FindOneKnexMigrationIncludeArgs = {
    include: KnexMigrationInclude;
    where: KnexMigrationWhereUniqueInput;
};
export declare type FindOneKnexMigrationIncludeArgsOptional = {
    include?: KnexMigrationInclude | null;
    where: KnexMigrationWhereUniqueInput;
};
export declare type ExtractFindOneKnexMigrationSelectArgs<S extends undefined | boolean | FindOneKnexMigrationSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneKnexMigrationSelectArgs ? S['select'] : true;
export declare type ExtractFindOneKnexMigrationIncludeArgs<S extends undefined | boolean | FindOneKnexMigrationIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneKnexMigrationIncludeArgs ? S['include'] : true;
/**
 * KnexMigration findMany
 */
export declare type FindManyKnexMigrationArgs = {
    select?: KnexMigrationSelect | null;
    include?: KnexMigrationInclude | null;
    where?: KnexMigrationWhereInput | null;
    orderBy?: KnexMigrationOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyKnexMigrationArgsRequired = {
    select: KnexMigrationSelect;
    include: KnexMigrationInclude;
    where?: KnexMigrationWhereInput | null;
    orderBy?: KnexMigrationOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyKnexMigrationSelectArgs = {
    select: KnexMigrationSelect;
    where?: KnexMigrationWhereInput | null;
    orderBy?: KnexMigrationOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyKnexMigrationSelectArgsOptional = {
    select?: KnexMigrationSelect | null;
    where?: KnexMigrationWhereInput | null;
    orderBy?: KnexMigrationOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyKnexMigrationIncludeArgs = {
    include: KnexMigrationInclude;
    where?: KnexMigrationWhereInput | null;
    orderBy?: KnexMigrationOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyKnexMigrationIncludeArgsOptional = {
    include?: KnexMigrationInclude | null;
    where?: KnexMigrationWhereInput | null;
    orderBy?: KnexMigrationOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyKnexMigrationSelectArgs<S extends undefined | boolean | FindManyKnexMigrationSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyKnexMigrationSelectArgs ? S['select'] : true;
export declare type ExtractFindManyKnexMigrationIncludeArgs<S extends undefined | boolean | FindManyKnexMigrationIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyKnexMigrationIncludeArgs ? S['include'] : true;
/**
 * KnexMigration create
 */
export declare type KnexMigrationCreateArgs = {
    select?: KnexMigrationSelect | null;
    include?: KnexMigrationInclude | null;
    data: KnexMigrationCreateInput;
};
export declare type KnexMigrationCreateArgsRequired = {
    select: KnexMigrationSelect;
    include: KnexMigrationInclude;
    data: KnexMigrationCreateInput;
};
export declare type KnexMigrationSelectCreateArgs = {
    select: KnexMigrationSelect;
    data: KnexMigrationCreateInput;
};
export declare type KnexMigrationSelectCreateArgsOptional = {
    select?: KnexMigrationSelect | null;
    data: KnexMigrationCreateInput;
};
export declare type KnexMigrationIncludeCreateArgs = {
    include: KnexMigrationInclude;
    data: KnexMigrationCreateInput;
};
export declare type KnexMigrationIncludeCreateArgsOptional = {
    include?: KnexMigrationInclude | null;
    data: KnexMigrationCreateInput;
};
export declare type ExtractKnexMigrationSelectCreateArgs<S extends undefined | boolean | KnexMigrationSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends KnexMigrationSelectCreateArgs ? S['select'] : true;
export declare type ExtractKnexMigrationIncludeCreateArgs<S extends undefined | boolean | KnexMigrationIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends KnexMigrationIncludeCreateArgs ? S['include'] : true;
/**
 * KnexMigration update
 */
export declare type KnexMigrationUpdateArgs = {
    select?: KnexMigrationSelect | null;
    include?: KnexMigrationInclude | null;
    data: KnexMigrationUpdateInput;
    where: KnexMigrationWhereUniqueInput;
};
export declare type KnexMigrationUpdateArgsRequired = {
    select: KnexMigrationSelect;
    include: KnexMigrationInclude;
    data: KnexMigrationUpdateInput;
    where: KnexMigrationWhereUniqueInput;
};
export declare type KnexMigrationSelectUpdateArgs = {
    select: KnexMigrationSelect;
    data: KnexMigrationUpdateInput;
    where: KnexMigrationWhereUniqueInput;
};
export declare type KnexMigrationSelectUpdateArgsOptional = {
    select?: KnexMigrationSelect | null;
    data: KnexMigrationUpdateInput;
    where: KnexMigrationWhereUniqueInput;
};
export declare type KnexMigrationIncludeUpdateArgs = {
    include: KnexMigrationInclude;
    data: KnexMigrationUpdateInput;
    where: KnexMigrationWhereUniqueInput;
};
export declare type KnexMigrationIncludeUpdateArgsOptional = {
    include?: KnexMigrationInclude | null;
    data: KnexMigrationUpdateInput;
    where: KnexMigrationWhereUniqueInput;
};
export declare type ExtractKnexMigrationSelectUpdateArgs<S extends undefined | boolean | KnexMigrationSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends KnexMigrationSelectUpdateArgs ? S['select'] : true;
export declare type ExtractKnexMigrationIncludeUpdateArgs<S extends undefined | boolean | KnexMigrationIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends KnexMigrationIncludeUpdateArgs ? S['include'] : true;
/**
 * KnexMigration updateMany
 */
export declare type KnexMigrationUpdateManyArgs = {
    data: KnexMigrationUpdateManyMutationInput;
    where?: KnexMigrationWhereInput | null;
};
/**
 * KnexMigration upsert
 */
export declare type KnexMigrationUpsertArgs = {
    select?: KnexMigrationSelect | null;
    include?: KnexMigrationInclude | null;
    where: KnexMigrationWhereUniqueInput;
    create: KnexMigrationCreateInput;
    update: KnexMigrationUpdateInput;
};
export declare type KnexMigrationUpsertArgsRequired = {
    select: KnexMigrationSelect;
    include: KnexMigrationInclude;
    where: KnexMigrationWhereUniqueInput;
    create: KnexMigrationCreateInput;
    update: KnexMigrationUpdateInput;
};
export declare type KnexMigrationSelectUpsertArgs = {
    select: KnexMigrationSelect;
    where: KnexMigrationWhereUniqueInput;
    create: KnexMigrationCreateInput;
    update: KnexMigrationUpdateInput;
};
export declare type KnexMigrationSelectUpsertArgsOptional = {
    select?: KnexMigrationSelect | null;
    where: KnexMigrationWhereUniqueInput;
    create: KnexMigrationCreateInput;
    update: KnexMigrationUpdateInput;
};
export declare type KnexMigrationIncludeUpsertArgs = {
    include: KnexMigrationInclude;
    where: KnexMigrationWhereUniqueInput;
    create: KnexMigrationCreateInput;
    update: KnexMigrationUpdateInput;
};
export declare type KnexMigrationIncludeUpsertArgsOptional = {
    include?: KnexMigrationInclude | null;
    where: KnexMigrationWhereUniqueInput;
    create: KnexMigrationCreateInput;
    update: KnexMigrationUpdateInput;
};
export declare type ExtractKnexMigrationSelectUpsertArgs<S extends undefined | boolean | KnexMigrationSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends KnexMigrationSelectUpsertArgs ? S['select'] : true;
export declare type ExtractKnexMigrationIncludeUpsertArgs<S extends undefined | boolean | KnexMigrationIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends KnexMigrationIncludeUpsertArgs ? S['include'] : true;
/**
 * KnexMigration delete
 */
export declare type KnexMigrationDeleteArgs = {
    select?: KnexMigrationSelect | null;
    include?: KnexMigrationInclude | null;
    where: KnexMigrationWhereUniqueInput;
};
export declare type KnexMigrationDeleteArgsRequired = {
    select: KnexMigrationSelect;
    include: KnexMigrationInclude;
    where: KnexMigrationWhereUniqueInput;
};
export declare type KnexMigrationSelectDeleteArgs = {
    select: KnexMigrationSelect;
    where: KnexMigrationWhereUniqueInput;
};
export declare type KnexMigrationSelectDeleteArgsOptional = {
    select?: KnexMigrationSelect | null;
    where: KnexMigrationWhereUniqueInput;
};
export declare type KnexMigrationIncludeDeleteArgs = {
    include: KnexMigrationInclude;
    where: KnexMigrationWhereUniqueInput;
};
export declare type KnexMigrationIncludeDeleteArgsOptional = {
    include?: KnexMigrationInclude | null;
    where: KnexMigrationWhereUniqueInput;
};
export declare type ExtractKnexMigrationSelectDeleteArgs<S extends undefined | boolean | KnexMigrationSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends KnexMigrationSelectDeleteArgs ? S['select'] : true;
export declare type ExtractKnexMigrationIncludeDeleteArgs<S extends undefined | boolean | KnexMigrationIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends KnexMigrationIncludeDeleteArgs ? S['include'] : true;
/**
 * KnexMigration deleteMany
 */
export declare type KnexMigrationDeleteManyArgs = {
    where?: KnexMigrationWhereInput | null;
};
/**
 * KnexMigration without action
 */
export declare type KnexMigrationArgs = {
    select?: KnexMigrationSelect | null;
    include?: KnexMigrationInclude | null;
};
export declare type KnexMigrationArgsRequired = {
    select: KnexMigrationSelect;
    include: KnexMigrationInclude;
};
export declare type KnexMigrationSelectArgs = {
    select: KnexMigrationSelect;
};
export declare type KnexMigrationSelectArgsOptional = {
    select?: KnexMigrationSelect | null;
};
export declare type KnexMigrationIncludeArgs = {
    include: KnexMigrationInclude;
};
export declare type KnexMigrationIncludeArgsOptional = {
    include?: KnexMigrationInclude | null;
};
export declare type ExtractKnexMigrationSelectArgs<S extends undefined | boolean | KnexMigrationSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends KnexMigrationSelectArgs ? S['select'] : true;
export declare type ExtractKnexMigrationIncludeArgs<S extends undefined | boolean | KnexMigrationIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends KnexMigrationIncludeArgs ? S['include'] : true;
/**
 * Model User
 */
export declare type User = {
    id: number;
    name: string | null;
};
export declare type UserScalars = 'id' | 'name';
export declare type UserSelect = {
    id?: boolean;
    name?: boolean;
};
export declare type UserInclude = {};
declare type UserDefault = {
    id: true;
    name: true;
};
declare type UserGetSelectPayload<S extends boolean | UserSelect> = S extends true ? User : S extends UserSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends UserScalars ? User[P] : never;
} : never;
declare type UserGetIncludePayload<S extends boolean | UserInclude> = S extends true ? User : S extends UserInclude ? {
    [P in CleanupNever<MergeTruthyValues<UserDefault, S>>]: P extends UserScalars ? User[P] : never;
} : never;
export interface UserDelegate {
    <T extends FindManyUserArgs>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    findOne<T extends FindOneUserArgs>(args: Subset<T, FindOneUserArgs>): T extends FindOneUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneUserSelectArgs ? Promise<UserGetSelectPayload<ExtractFindOneUserSelectArgs<T>>> : T extends FindOneUserIncludeArgs ? Promise<UserGetIncludePayload<ExtractFindOneUserIncludeArgs<T>>> : UserClient<User>;
    findMany<T extends FindManyUserArgs>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    create<T extends UserCreateArgs>(args: Subset<T, UserCreateArgs>): T extends UserCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectCreateArgs ? Promise<UserGetSelectPayload<ExtractUserSelectCreateArgs<T>>> : T extends UserIncludeCreateArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeCreateArgs<T>>> : UserClient<User>;
    delete<T extends UserDeleteArgs>(args: Subset<T, UserDeleteArgs>): T extends UserDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectDeleteArgs ? Promise<UserGetSelectPayload<ExtractUserSelectDeleteArgs<T>>> : T extends UserIncludeDeleteArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeDeleteArgs<T>>> : UserClient<User>;
    update<T extends UserUpdateArgs>(args: Subset<T, UserUpdateArgs>): T extends UserUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpdateArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpdateArgs<T>>> : T extends UserIncludeUpdateArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpdateArgs<T>>> : UserClient<User>;
    deleteMany<T extends UserDeleteManyArgs>(args: Subset<T, UserDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends UserUpdateManyArgs>(args: Subset<T, UserUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends UserUpsertArgs>(args: Subset<T, UserUpsertArgs>): T extends UserUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpsertArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpsertArgs<T>>> : T extends UserIncludeUpsertArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpsertArgs<T>>> : UserClient<User>;
}
export declare class UserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    private readonly _document;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * User findOne
 */
export declare type FindOneUserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserSelectArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserSelectArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserIncludeArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserIncludeArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type ExtractFindOneUserSelectArgs<S extends undefined | boolean | FindOneUserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneUserSelectArgs ? S['select'] : true;
export declare type ExtractFindOneUserIncludeArgs<S extends undefined | boolean | FindOneUserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneUserIncludeArgs ? S['include'] : true;
/**
 * User findMany
 */
export declare type FindManyUserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserSelectArgs = {
    select: UserSelect;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserSelectArgsOptional = {
    select?: UserSelect | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserIncludeArgs = {
    include: UserInclude;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserIncludeArgsOptional = {
    include?: UserInclude | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyUserSelectArgs<S extends undefined | boolean | FindManyUserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyUserSelectArgs ? S['select'] : true;
export declare type ExtractFindManyUserIncludeArgs<S extends undefined | boolean | FindManyUserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyUserIncludeArgs ? S['include'] : true;
/**
 * User create
 */
export declare type UserCreateArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserCreateInput;
};
export declare type UserCreateArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserCreateInput;
};
export declare type UserSelectCreateArgs = {
    select: UserSelect;
    data: UserCreateInput;
};
export declare type UserSelectCreateArgsOptional = {
    select?: UserSelect | null;
    data: UserCreateInput;
};
export declare type UserIncludeCreateArgs = {
    include: UserInclude;
    data: UserCreateInput;
};
export declare type UserIncludeCreateArgsOptional = {
    include?: UserInclude | null;
    data: UserCreateInput;
};
export declare type ExtractUserSelectCreateArgs<S extends undefined | boolean | UserSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectCreateArgs ? S['select'] : true;
export declare type ExtractUserIncludeCreateArgs<S extends undefined | boolean | UserIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeCreateArgs ? S['include'] : true;
/**
 * User update
 */
export declare type UserUpdateArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserUpdateArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserSelectUpdateArgs = {
    select: UserSelect;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserSelectUpdateArgsOptional = {
    select?: UserSelect | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeUpdateArgs = {
    include: UserInclude;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeUpdateArgsOptional = {
    include?: UserInclude | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type ExtractUserSelectUpdateArgs<S extends undefined | boolean | UserSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpdateArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpdateArgs<S extends undefined | boolean | UserIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpdateArgs ? S['include'] : true;
/**
 * User updateMany
 */
export declare type UserUpdateManyArgs = {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
};
/**
 * User upsert
 */
export declare type UserUpsertArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserUpsertArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserSelectUpsertArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserSelectUpsertArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserIncludeUpsertArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserIncludeUpsertArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type ExtractUserSelectUpsertArgs<S extends undefined | boolean | UserSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpsertArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpsertArgs<S extends undefined | boolean | UserIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpsertArgs ? S['include'] : true;
/**
 * User delete
 */
export declare type UserDeleteArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type UserDeleteArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type UserSelectDeleteArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
};
export declare type UserSelectDeleteArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeDeleteArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeDeleteArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type ExtractUserSelectDeleteArgs<S extends undefined | boolean | UserSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectDeleteArgs ? S['select'] : true;
export declare type ExtractUserIncludeDeleteArgs<S extends undefined | boolean | UserIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeDeleteArgs ? S['include'] : true;
/**
 * User deleteMany
 */
export declare type UserDeleteManyArgs = {
    where?: UserWhereInput | null;
};
/**
 * User without action
 */
export declare type UserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
};
export declare type UserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
};
export declare type UserSelectArgs = {
    select: UserSelect;
};
export declare type UserSelectArgsOptional = {
    select?: UserSelect | null;
};
export declare type UserIncludeArgs = {
    include: UserInclude;
};
export declare type UserIncludeArgsOptional = {
    include?: UserInclude | null;
};
export declare type ExtractUserSelectArgs<S extends undefined | boolean | UserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectArgs ? S['select'] : true;
export declare type ExtractUserIncludeArgs<S extends undefined | boolean | UserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeArgs ? S['include'] : true;
/**
 * Deep Input Types
 */
export declare type KnexMigrationWhereInput = {
    id?: number | IntFilter | null;
    batch?: number | NullableIntFilter | null | null;
    migrationTime?: string | Date | NullableDateTimeFilter | null | null;
    name?: string | NullableStringFilter | null | null;
    AND?: Enumerable<KnexMigrationWhereInput>;
    OR?: Enumerable<KnexMigrationWhereInput>;
    NOT?: Enumerable<KnexMigrationWhereInput>;
};
export declare type KnexMigrationWhereUniqueInput = {
    id?: number | null;
};
export declare type UserWhereInput = {
    id?: number | IntFilter | null;
    name?: string | NullableStringFilter | null | null;
    AND?: Enumerable<UserWhereInput>;
    OR?: Enumerable<UserWhereInput>;
    NOT?: Enumerable<UserWhereInput>;
};
export declare type UserWhereUniqueInput = {
    id?: number | null;
};
export declare type KnexMigrationCreateInput = {
    batch?: number | null;
    migrationTime?: string | Date | null;
    name?: string | null;
};
export declare type KnexMigrationUpdateInput = {
    id?: number | null;
    batch?: number | null;
    migrationTime?: string | Date | null;
    name?: string | null;
};
export declare type KnexMigrationUpdateManyMutationInput = {
    id?: number | null;
    batch?: number | null;
    migrationTime?: string | Date | null;
    name?: string | null;
};
export declare type UserCreateInput = {
    name?: string | null;
};
export declare type UserUpdateInput = {
    id?: number | null;
    name?: string | null;
};
export declare type UserUpdateManyMutationInput = {
    id?: number | null;
    name?: string | null;
};
export declare type IntFilter = {
    equals?: number | null;
    not?: number | IntFilter | null;
    in?: Enumerable<number>;
    notIn?: Enumerable<number>;
    lt?: number | null;
    lte?: number | null;
    gt?: number | null;
    gte?: number | null;
};
export declare type NullableIntFilter = {
    equals?: number | null | null;
    not?: number | null | NullableIntFilter | null;
    in?: Enumerable<number>;
    notIn?: Enumerable<number>;
    lt?: number | null;
    lte?: number | null;
    gt?: number | null;
    gte?: number | null;
};
export declare type NullableDateTimeFilter = {
    equals?: string | Date | null | null;
    not?: string | Date | null | NullableDateTimeFilter | null;
    in?: Enumerable<string | Date>;
    notIn?: Enumerable<string | Date>;
    lt?: string | Date | null;
    lte?: string | Date | null;
    gt?: string | Date | null;
    gte?: string | Date | null;
};
export declare type NullableStringFilter = {
    equals?: string | null | null;
    not?: string | null | NullableStringFilter | null;
    in?: Enumerable<string>;
    notIn?: Enumerable<string>;
    lt?: string | null;
    lte?: string | null;
    gt?: string | null;
    gte?: string | null;
    contains?: string | null;
    startsWith?: string | null;
    endsWith?: string | null;
};
export declare type KnexMigrationOrderByInput = {
    id?: OrderByArg | null;
    batch?: OrderByArg | null;
    migrationTime?: OrderByArg | null;
    name?: OrderByArg | null;
};
export declare type UserOrderByInput = {
    id?: OrderByArg | null;
    name?: OrderByArg | null;
};
/**
 * Batch Payload for updateMany & deleteMany
 */
export declare type BatchPayload = {
    count: number;
};
/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
